#!/usr/bin/env python
#
# requires root privs
from logging import debug
import os
from subprocess import check_call, CalledProcessError

# todo: variables that can be set by user
EC2_DIR = 'test'
IMAGE_NAME = 'em7-base.img'
BLOCK_SIZE = '1M'
BLOCK_COUNT = '500' # block size * count = image size

# derived variables that probably never need to change
IMAGE_DIR = '{}/images'.format(EC2_DIR)
MOUNT_DIR = '{}/mnt'.format(EC2_DIR)
IMAGE = '{}/{}'.format(IMAGE_DIR, IMAGE_NAME)

# image innards that facilitate installation
SKELETON = ['dev', 'etc', 'proc', 'sys', 'var/cache', 'var/log', 
            'var/lock', 'var/lib/rpm']

BIND_MOUNTS = ['dev', 'dev/pts', 'dev/shm', 'proc', 'sys']

DEVICES = ['console', 'null', 'zero', 'urandom']

def cleanup_mounts():
    """
    Unmount bound system mount points, if present.  Then unmount the image.
    
    The order is important if mounts are nested, so do them in reverse.
    """
    for path in BIND_MOUNTS.reverse():
        mount_point = '{}/{}'.format(MOUNT_DIR, path)
        debug('checking {}'.format(mount_point))
        if os.path.ismount(mount_point):
            debug('unmounting {}'.format(mount_point))
            check_call(['umount', mount_point])
    check_call(['umount', MOUNT_DIR])

def remove_image():
    "Cleanup when during init or when errors prevent successful image creation."
    if os.path.ismount(MOUNT_DIR):
        check_call(['umount', MOUNT_DIR])

    if os.path.exists(IMAGE):
        os.remove(IMAGE)

def create_image():
    "Create an empty image file and mount it."
    remove_image()
    commands = []
    
    if_arg = 'if=/dev/zero'
    of_arg = 'of={}'.format(IMAGE)
    bs_arg = 'bs={}'.format(BLOCK_SIZE)
    bc_arg = 'count={}'.format(BLOCK_COUNT)
    commands.append(['dd', if_arg, of_arg, bs_arg, bc_arg])
    
    commands.append(['mkfs.ext3', '-F', '-j', IMAGE])
    commands.append(['mount', '-o','loop', IMAGE, MOUNT_DIR])
    
    try:
        for cmd in commands:
            check_call(cmd)
    except CalledProcessError, e:
        remove_image()
        raise

def make_device_files(target_dir, file_names):
    cmd = ['MAKEDEV', '-d', '{}/dev'.format(target_dir), '-x', 'dummy']
    last_arg = len(cmd) - 1
    for dev in file_names:
        cmd[last_arg] = dev
        debug('make_device_files: {}'.format(cmd))
        check_call(cmd)
    
def make_directories(target, dirs, fail_exists=False):
    """
    Make multiple directories, including intermediate parents.
    
    dirs: a sequence of strings containing relative path names
    target_root: the directory to create in
    fail_exists: don't bail out if the directory is already there
    
    TODO: library candidate
    """
    try:
        for dir in dirs:
            os.makedirs('{}/{}'.format(target, dir))
    except OSError, e:
        if e.errno == 17 and fail_exists:
            raise

def bind_mount(target, sources):
    """
    Bind mount (overlay) a file or directory onto another.
    
    target: directory containing mount points to bind to
    sources: list of source paths to mount
    """
    cmd = ['mount', '-o', 'bind', 'source', 'target']
    for source in sources:
        cmd[3] = '/{}'.format(source)
        cmd[4] = '{}/{}'.format(target, source)
        debug('bind_mount: {}'.format(cmd))
        check_call(cmd)
    
def prep_image():
    """
    Prepare for chroot operations by initializing directory structure and 
    device files.  Bind to running kernel filesystems.
    """
    try:            
        make_directories(MOUNT_DIR, SKELETON)
        make_device_files(MOUNT_DIR, DEVICES)
        bind_mount(MOUNT_DIR, BIND_MOUNTS)
    except CalledProcessError, e:
        cleanup_mounts()
        raise

# todo: let user specify creation dir and mount point
make_directories('.', [IMAGE_DIR, MOUNT_DIR])
create_image()
prep_image()
cleanup_mounts()